// Include Libraries
#include <opencv2/opencv.hpp>
#include <opencv2/imgproc.hpp>
#include <iostream>
#include <time.h>
#include <stdlib.h> // For getloadavg

// Namespace to nullify use of cv::function(); syntax
using namespace std;
using namespace cv;

std::string gstreamer_pipeline(int capture_width, int capture_height, int framerate, int display_width, int display_height) {
    return

            " libcamerasrc ! video/x-raw, "
            " width=(int)" + std::to_string(capture_width) + ","
            " height=(int)" + std::to_string(capture_height) + ","
            " framerate=(fraction)" + std::to_string(framerate) +"/1 !"
            " videoconvert ! appsink";
}

int main()
{
	// Start and end times
	clock_t begin, stop;

	// Number of frames to capture to calculate fps
	int num_frames = 30, counter=0;
	// Frames per second
	double fps;

	int frame_width;
	int frame_height;

	double avgs[3];

	//pipeline parameters
    int capture_width = 640;
    int capture_height = 480;
    int framerate = 60 ;
    int display_width = capture_width ;
    int display_height = capture_height;

    //reset frame average
    std::string pipeline = gstreamer_pipeline(capture_width, capture_height, framerate,
                                              display_width, display_height);


	// initialize a video capture object
	cout << "Initiating video stream device" << endl;

	// Change this accordingly if using V4L or GSTREAMER
	//VideoCapture vid_capture(3, CAP_V4L);
	VideoCapture vid_capture(pipeline, CAP_GSTREAMER);

	// Print error message if the stream is invalid
	if (!vid_capture.isOpened())
	{
		cout << "Error opening video stream or file" << endl;
	}

	else
	{
		vid_capture.set(CAP_PROP_FRAME_WIDTH, capture_width);
		vid_capture.set(CAP_PROP_FRAME_HEIGHT, capture_height);
		vid_capture.set(CAP_PROP_FPS, framerate);

		fps = vid_capture.get(5);
		cout << "Frames per second : " << fps << endl;

		// Get video size
		frame_width = static_cast<int>(vid_capture.get(cv::CAP_PROP_FRAME_WIDTH));
		frame_height = static_cast<int>(vid_capture.get(cv::CAP_PROP_FRAME_HEIGHT));
		cout << "Dimensions : " << frame_width << " X " << frame_height << endl;

	}

	// Define the codec and create VideoWriter object.The output is stored in 'outcpp.avi' file.
	// VideoWriter(filename, apiPreference, fourcc, fps, frameSize[, isColor])
	// filename: pathname for the output video file
	// apiPreference:  API backends identifier
	// fourcc: 4-character code of codec, used to compress the frames (fourcc)
	// fps: Frame rate of the created video stream
	// frame_size: Size of the video frames
	// isColor: If not zero, the encoder will expect and encode color frames. Else it will work with grayscale frames (the flag is currently supported on Windows only).
	VideoWriter video("outcpp.avi", cv::CAP_FFMPEG /*cv::CAP_GSTREAMER*/, cv::VideoWriter::fourcc('M','J','P','G'), framerate, Size(capture_width,capture_height));
	//VideoWriter video("/media/outcpp.avi", cv::VideoWriter::fourcc('M','J','P','G'), framerate, Size(frame_width,frame_height));
	//VideoWriter video("/media/outcpp.avi", cv::VideoWriter::fourcc('X','2','6','4'), framerate, Size(frame_width,frame_height));
	//VideoWriter video("/media/outcpp.avi", cv::VideoWriter::fourcc('X','V','I','D'), framerate, Size(frame_width,frame_height));
	//VideoWriter video("/media/outcpp.avi", cv::CAP_FFMPEG /*CAP_GSTREAMER*/, cv::VideoWriter::fourcc('M','P','4','V'), 10, Size(640,360 /*frame_width,frame_height*/));
	//For streaming over network
	//VideoWriter video("appsrc ! videoconvert ! x264enc tune=zerolatency bitrate=500 speed-preset=superfast ! rtph264pay ! udpsink host=127.0.0.1 port=5000", cv::CAP_GSTREAMER, 0, framerate, Size(frame_width,frame_height),true);
	if(video.isOpened())
    {
            cout << "Video opened for writing" << endl;
    }
    else
    {
            cout << "Ooops, something went wrong when opening video for writing" << endl;
    }

	// Read the frames to the last frame
	while (vid_capture.isOpened())
	{
		// Initialise frame matrix
		Mat frame;

		// Initialize a boolean to check if frames are there or not
		bool isSuccess = vid_capture.read(frame);

		// If frames are present, show it
		if(isSuccess == true)
		{
			if(counter == 0)
			{
				//Getting the first frame time to calculate fps
				begin=clock();
			}
			counter++;

			if(counter >= num_frames)
			{
				stop=clock();
				// Elapsed time
				double seconds = (double(stop) - double(begin)) / double(CLOCKS_PER_SEC);
				cout << "Time taken : " << seconds << " seconds" << endl;

				// Calculate frames per second
				fps= double(num_frames) / double(seconds);
				cout << "Estimated frames per second : " << fps << endl;
				counter=0;
			}

			// putText(image, text, org, font, fontScale, color)
			// As usual, the first argument is the input image.
			// The next argument is the actual text string that we want to annotate the image with.
			// The third argument specifies the starting location for the top left corner of the text string.
			// The next two arguments specify the font style and scale.
			// OpenCV supports several font-face styles from the Hershey font collection, and an italic font as well. Check out this list:
			//		FONT_HERSHEY_SIMPLEX        = 0,
			//		FONT_HERSHEY_PLAIN          = 1,
			//		FONT_HERSHEY_DUPLEX         = 2,
			//		FONT_HERSHEY_COMPLEX        = 3,
			//		FONT_HERSHEY_TRIPLEX        = 4,
			//		FONT_HERSHEY_COMPLEX_SMALL  = 5,
			//		FONT_HERSHEY_SCRIPT_SIMPLEX = 6,
			//		FONT_HERSHEY_SCRIPT_COMPLEX = 7,
			//		FONT_ITALIC                 = 16
			//	The font scale is a floating-point value, used to scale the base size of the font up or down. Depending on the resolution of your image, select an appropriate font scale.
			//	The last required argument is the color, which is specified as a BGR triplet.
			//	putText(imageText, "I am a Happy dog!", Point(50,350), FONT_HERSHEY_COMPLEX, 1.5, Scalar(250,225,100));


			//getloadavg(avgs, 3);

			//putText(frame, "FPS: " + to_string(fps), Point(25, 25), FONT_HERSHEY_SIMPLEX, 0.7, Scalar(255,255,255),2);
			//putText(frame, "CPU: " + to_string(avgs[0]) + "%", Point(25, 50), FONT_HERSHEY_SIMPLEX, 0.7, Scalar(255,255,255),2);

			// Write the frame into the file 'outcpp.avi'
			//video.write(frame);


			//display frames
			//imshow("Frame", frame);
		}

		// If frames are not there, close it
		if (isSuccess == false)
		{
			cout << "Video camera is disconnected" << endl;
			break;
		}

	}
	// Release the video capture object
	vid_capture.release();
	destroyAllWindows();
	return 0;
}
