// Include Libraries
#include <opencv2/opencv.hpp>
#include <opencv2/imgproc.hpp>
#include <iostream>
#include <time.h>
#include <stdlib.h> // For getloadavg

// Namespace to nullify use of cv::function(); syntax
using namespace std;
using namespace cv;

std::string gstreamer_pipeline(int capture_width, int capture_height, int framerate, int display_width, int display_height) {
    return

            " libcamerasrc ! video/x-raw, "
            " width=(int)" + std::to_string(capture_width) + ","
            " height=(int)" + std::to_string(capture_height) + ","
            " framerate=(fraction)" + std::to_string(framerate) +"/1 !"
            " videoconvert ! appsink";
}

int main()
{
	// Start and end times
	clock_t begin, stop;

	// Number of frames to capture to calculate fps
	int num_frames = 30, counter=0;
	// Frames per second
	double fps;

	int frame_width;
	int frame_height;

	double avgs[3];

	//pipeline parameters
    int capture_width = 720;
    int capture_height = 480;
    int framerate = 60 ;
    int display_width = 640;
    int display_height = 480;

    //reset frame average
    std::string pipeline = gstreamer_pipeline(capture_width, capture_height, framerate,
                                              display_width, display_height);


	// initialize a video capture object
	cout << "Initiating video stream device" << endl;

	// Change this accordingly if using V4L or GSTREAMER
	//VideoCapture vid_capture(3, CAP_V4L);
	VideoCapture vid_capture(pipeline, CAP_GSTREAMER);

	// Print error message if the stream is invalid
	if (!vid_capture.isOpened())
	{
		cout << "Error opening video stream or file" << endl;
	}

	else
	{
		vid_capture.set(CAP_PROP_FRAME_WIDTH, capture_width);
		vid_capture.set(CAP_PROP_FRAME_HEIGHT, capture_height);
		vid_capture.set(CAP_PROP_FPS, framerate);

		fps = vid_capture.get(5);
		cout << "Frames per second : " << fps << endl;

		// Get video size
		frame_width = static_cast<int>(vid_capture.get(cv::CAP_PROP_FRAME_WIDTH));
		frame_height = static_cast<int>(vid_capture.get(cv::CAP_PROP_FRAME_HEIGHT));
		cout << "Dimensions : " << frame_width << " X " << frame_height << endl;

	}

	// Define the codec and create VideoWriter object.The output is stored in 'outcpp.avi' file.
	// VideoWriter(filename, apiPreference, fourcc, fps, frameSize[, isColor])
	// filename: pathname for the output video file
	// apiPreference:  API backends identifier
	// fourcc: 4-character code of codec, used to compress the frames (fourcc)
	// fps: Frame rate of the created video stream
	// frame_size: Size of the video frames
	// isColor: If not zero, the encoder will expect and encode color frames. Else it will work with grayscale frames (the flag is currently supported on Windows only).
	VideoWriter video("outcpp.avi", cv::CAP_FFMPEG /*cv::CAP_GSTREAMER*/, cv::VideoWriter::fourcc('M','J','P','G'), framerate, Size(capture_width,capture_height));
	//VideoWriter video("/media/outcpp.avi", cv::VideoWriter::fourcc('M','J','P','G'), framerate, Size(frame_width,frame_height));
	//VideoWriter video("/media/outcpp.avi", cv::VideoWriter::fourcc('X','2','6','4'), framerate, Size(frame_width,frame_height));
	//VideoWriter video("/media/outcpp.avi", cv::VideoWriter::fourcc('X','V','I','D'), framerate, Size(frame_width,frame_height));
	//VideoWriter video("/media/outcpp.avi", cv::CAP_FFMPEG /*CAP_GSTREAMER*/, cv::VideoWriter::fourcc('M','P','4','V'), 10, Size(640,360 /*frame_width,frame_height*/));
	//For streaming over network
	//VideoWriter video("appsrc ! videoconvert ! x264enc tune=zerolatency bitrate=500 speed-preset=superfast ! rtph264pay ! udpsink host=127.0.0.1 port=5000", cv::CAP_GSTREAMER, 0, framerate, Size(frame_width,frame_height),true);
	if(video.isOpened())
    {
            cout << "Video opened for writing" << endl;
    }
    else
    {
            cout << "Ooops, something went wrong when opening video for writing" << endl;
    }

	// Read the frames to the last frame
	while (vid_capture.isOpened())
	{
		// Initialise frame matrix
		Mat frame;

		// Initialize a boolean to check if frames are there or not
		bool isSuccess = vid_capture.read(frame);

		// If frames are present, show it
		if(isSuccess == true)
		{
			if(counter == 0)
			{
				//Getting the first frame time to calculate fps
				begin=clock();
			}
			counter++;

			if(counter >= num_frames)
			{
				stop=clock();
				// Elapsed time
				double seconds = (double(stop) - double(begin)) / double(CLOCKS_PER_SEC);
				cout << "Time take